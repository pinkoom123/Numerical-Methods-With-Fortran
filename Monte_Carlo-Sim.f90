MODULE MONTE_CARLO
    IMPLICIT NONE
    CONTAINS

    ! Subroutine to estimate Pi using the Hit-or-Miss method
    SUBROUTINE estimate_pi_hit_miss(N, pi_estimate)
        INTEGER, INTENT(IN) :: N
        REAL(8), INTENT(OUT) :: pi_estimate
        INTEGER :: i, inside_circle
        REAL(8) :: x, y
        
        inside_circle = 0

        DO i = 1, N
            CALL RANDOM_NUMBER(x)
            CALL RANDOM_NUMBER(y)
            x = 2.0 * x - 1.0  
            y = 2.0 * y - 1.0  
            IF (x**2 + y**2 <= 1.0) THEN
                inside_circle = inside_circle + 1
            END IF
        END DO

        pi_estimate = 4.0 * inside_circle / N  
    END SUBROUTINE estimate_pi_hit_miss


   SUBROUTINE generate_points_rejection(N, xmin, xmax, f_max, points)
    INTEGER, INTENT(IN) :: N             ! Number of points to generate
    REAL(8), INTENT(IN) :: xmin, xmax    ! Range [xmin, xmax]
    REAL(8), INTENT(IN) :: f_max         ! Maximum value of f(x)
    REAL(8), INTENT(OUT) :: points(N)    ! Array to store the accepted points
    INTEGER :: count                     ! Counter for accepted points
    REAL(8) :: x, r                      ! Random values x and r

    ! Ensure the counter is reset
    count = 0

    DO WHILE (count < N)
        ! Generate x uniformly in [xmin, xmax]
        CALL RANDOM_NUMBER(x)
        x = xmin + (xmax - xmin) * x     ! Scale x to [xmin, xmax]

        ! Generate r in [0, 1]
        CALL RANDOM_NUMBER(r)

        ! Acceptance check based on f(x) = 3x^2
        IF (r <= (3.0 * x**2) / f_max) THEN
            count = count + 1
            points(count) = x            ! Accept x and store it in points
        END IF
    END DO
END SUBROUTINE generate_points_rejection

   
  ! Subroutine to estimate the integral  using the Hit-and-Miss method
    SUBROUTINE estimate_integral_hit_miss(N, integral_estimate)
        INTEGER, INTENT(IN) :: N
        REAL(8), INTENT(OUT) :: integral_estimate
        INTEGER :: i, below_curve
        REAL(8) :: x, y, max_f, a, b
        max_f = 27.0                    ! Max value of 3x^2 on [0, 3]
        
        below_curve = 0
        a = 0.0
        b = 3.0

        DO i = 1, N
            CALL RANDOM_NUMBER(x)
            CALL RANDOM_NUMBER(y)
            x = a + (b - a) * x           ! Scale x to [0, 3]
            y = y * max_f                 ! Scale y to [0, max_f]
            IF (y <= 3.0 * x**2) THEN
                below_curve = below_curve + 1
            END IF
        END DO

        integral_estimate = (b - a) * max_f * below_curve / N
    END SUBROUTINE estimate_integral_hit_miss 
    
     !  Subroutine to estimate the integral  e^(-x^2) dx using the crude Monte Carlo method
    SUBROUTINE estimate_integral_monte_carlo(N, crude_integral_estimate)
        INTEGER, INTENT(IN) :: N
        REAL(8), INTENT(OUT) :: crude_integral_estimate
        INTEGER :: i
        REAL(8) :: x, sum
        sum = 0.0

        DO i = 1, N
            CALL RANDOM_NUMBER(x)
            sum = sum + EXP(-x**2)
        END DO

        crude_integral_estimate = sum / N  ! Average the results
    END SUBROUTINE estimate_integral_monte_carlo

     ! Bonus: Subroutine to estimate Pi using a crude Monte Carlo method 
    SUBROUTINE estimate_pi_monte_carlo(N, pi_estimate)
        INTEGER, INTENT(IN) :: N
        REAL(8), INTENT(OUT) :: pi_estimate
        INTEGER :: i, inside_circle
        REAL(8) :: x, y
        inside_circle = 0

        DO i = 1, N
            CALL RANDOM_NUMBER(x)
            CALL RANDOM_NUMBER(y)
            x = 2.0 * x - 1.0             ! Scale x to [-1, 1]
            y = 2.0 * y - 1.0             ! Scale y to [-1, 1]
            IF (x**2 + y**2 <= 1.0) THEN
                inside_circle = inside_circle + 1
            END IF
        END DO

        pi_estimate = 4.0 * inside_circle / N  ! Estimate Pi as area of the unit circle
    END SUBROUTINE estimate_pi_monte_carlo
    
    
    
    

END MODULE MONTE_CARLO


PROGRAM main
    USE MONTE_CARLO
    IMPLICIT NONE
    INTEGER, PARAMETER :: N = 10000
    REAL(8) :: pi_hit_miss, xmin, xmax, f_max,integral_estimate, crude_integral_estimate, pi_monte_carlo
    REAL(8), ALLOCATABLE :: points(:)
    INTEGER :: i

    ! range and maximum value for f(x)
    xmin = 0.0
    xmax = 1.0
    f_max = 3.0  ! This is the maximum value of f(x) 

    ! Allocate memory for points generated by rejection method
    ALLOCATE(points(N))

    ! Estimate Pi using Hit-or-Miss method
    CALL estimate_pi_hit_miss(N, pi_hit_miss)
    PRINT *, "Estimated Pi using Hit-or-Miss: ", pi_hit_miss
    
     PRINT *
    ! Generate points from f(x) = 3x^2 using the rejection method and save to file
    CALL generate_points_rejection(N, xmin, xmax, f_max, points)
    OPEN(unit=10, file="distribution_points.txt", status="replace")
      DO i = 1, N
          WRITE(10, '(F8.5)') points(i)
       END DO
    CLOSE(10)

    PRINT *, "Generated points from f(x) = 3x^2 saved to 'distribution_points.txt'"
    
    PRINT *
    !Estimate integral 3x^2 dx using Hit-and-Miss method
    CALL estimate_integral_hit_miss(N, integral_estimate)
    PRINT *, "Estimated Integral 3x^2 dx using Hit-and-Miss: ", integral_estimate
    
    PRINT *
   ! Estimate integral  e^(-x^2) dx using crude Monte Carlo method
    CALL estimate_integral_monte_carlo(N, crude_integral_estimate)
    PRINT *, "Estimated Integral  e^(-x^2) dx using Monte Carlo: ", crude_integral_estimate
    
    PRINT *
    ! Bonus: Estimate Ï€ using the crude Monte Carlo method by integrating
    CALL estimate_pi_monte_carlo(N, pi_monte_carlo)
    PRINT *, "Estimated Pi using Crude Monte Carlo integration: ", pi_monte_carlo
    
    DEALLOCATE(points)
END PROGRAM main

